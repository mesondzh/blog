---
title: TCP/IP协议😇
date: 2018-08-21 23:29:08
updated: 2018-08-21 23:29:08
description: 介绍TCP/IP协议相关知识
categories: 计算机基础
type: photo
photos:
- https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821214133.jpg
tags: 
- TCP/IP
- 计算机网络
music-id: 116493
---

## TCP/IP协议<i class="fa fa-internet-explorer" aria-hidden="true"></i>

TCP/IP不是一个协议，而是一个协议族的统称。里面包括IP协议、IMCP协议、TCP协议。

TCP/IP分层：

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215017.png)

这里有几个需要注意的知识点：

- 互联网地址：也就是IP地址，一般为网络号+子网号+主机号
- 域名系统：通俗的来说，就是一个数据库，可以将主机名转换成IP地址
- RFC：TCP/IP协议的标准文档
- 端口号：一个逻辑号码，IP包所带有的标记
- Socket：应用编程接口

数据链路层的工作特性：

- 为IP模块发送和接收IP数据报
- 为ARP模块发送ARP请求和接收ARP应答（ARP：地址解析协议，将IP地址转换成MAC地址）
- 为RARP发送RARP请求和接收RARP应答

接下来我们了解一下TCP/IP的工作流程：

数据链路层从ARP得到数据的传递信息，再从IP得到具体的数据信息

## IP协议

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215250.png)

IP协议头当中，最重要的就是TTL（IP允许通过的最大网段数量）字段（八位），规定该数据包能穿过几个路由之后才会被抛弃。

## IP路由选择

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215336.png)

## ARP协议工作原理

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215402.png)

## ICMP协议（网络控制文协议）

将IP数据包不能传送的错误信息传送给主机

查询报文

1. ping查询：主机是否可达，通过计算间隔时间和传送多少个包的数量
2. 子网掩码
3. 时间戳：获得当前时间

差错报文

不产生的情况：

1. ICMP差错报文不产生差错报文
2. 源地址为零地址、环目地址、广播地址、多播地址

## IP路由器选择协议

### 静态路由选择

先来看路由选择工作流程：

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215524.png)



1. 配置接口以默认方式生成路由表项，或者使用route add手动添加表项
2. ICMP报文（ICMP重定向报文）更新表项
3. 动态路由选择（只使用在路由之间）

### RIP（路由信息协议）

分布式的基于距离向量（路由器到每一个目的网络的距离记录）的路由选择协议

router承担的工作：

1. 给每一个已知路由器发送RIP请求报文，要求给出完整的路由表
2. 如果接受请求，就将自己的路由表交给请求者；如果没有，就处理IP请求表项（自己部分+跳数/没有的部分+16）
3. 接受回应，更新路由表
4. 定期更新路由表（一般为30s，只能说太频繁~）

### OSPF（开放最短路径优先协议）

分布式链路状态（和这两个路由器都有接口的网络）协议

1. 当链路状态发生变化时，采用可靠的洪泛法，向所有的路由器发送信息（相邻的所有路由器的链路状态）
2. 最终会建立一个全网的拓扑结构图

### TCP/IP的三次握手，四次分手

首先我们先来了解TCP报文段：

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215736.png)

### 三次握手的过程

客户端我们用A表示，服务器端用B表示，前提：A主动打开，B被动打开。

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821215953.png)



1. 在建立连接之前，B先创建TCB（传输控制块），准备接受客户进程的连接请求，处于LISTEN（监听）状态
2. A首先创建TCB，然后向B发出连接请求，SYN置1，同时选择初始序号seq=x，进入SYN-SEND（同步已发送）状态
3. B收到连接请求后向A发送确认，SYN置1，ACK置1，同时产生一个确认序号ack=x+1。同时随机选择初始序号seq=y，进入SYN-RCVD（同步收到）状态
4. A收到确认连接请求后，ACK置1，确认号ack=y+1，seq=x+1，进入到ESTABLISHED（已建立连接）状态。向B发出确认连接，最后B也进入到ESTABLISHED（已建立连接）状态。

简单来说，就是

1. 建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认
2. 服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态
3. 客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手

在此穿插一个知识点就是SYN攻击，那么什么是SYN攻击？发生的条件是什么？怎么避免？

在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是 Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址 是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网 络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：  `#netstat -nap | grep SYN_RECV`

### 四次分手的过程

客户端我们用A表示，服务器端用B表示。由于TCP连接时是全双工的，因此每个方向都必须单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的链接。收到一个FIN只是意味着这一方向上没有数据流动，既不会在收到数据，但是在这个TCP连接上仍然能够发送数据，知道这一方向也发送了FIN，首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

前提：A主动关闭，B被动关闭

![](https://raw.githubusercontent.com/ds19991999/githubimg/master/picgo/20180821220149.png)

***为什么连接的时候是三次握手，而断开连接的时候需要四次挥手？***

这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再 发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。

1. A发送一个FIN，用来关闭A到B的数据传送，A进入FIN_WAIT_1状态。
2. B收到FIN后，发送一个ACK给A，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），B进入CLOSE_WAIT状态。
3. B发送一个FIN，用来关闭B到A的数据传送，B进入LAST_ACK状态。
4. A收到FIN后，A进入TIME_WAIT状态，接着发送一个ACK给B，确认序号为收到序号+1，B进入CLOSED状态，完成四次挥手。

简单来说就是

1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送（报文段4）。
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1（报文段5）。和SYN一样，一个FIN将占用一个序号。
3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A（报文段6）。
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1（报文段7）。

A在进入到TIME-WAIT状态后，并不会马上释放TCP，必须经过时间等待计时器设置的时间2MSL（最长报文段寿命），A才进入到CLOSED状态。为什么？

1. 为了保证A发送的最后一个ACK报文段能够到达B
2. 防止“已失效的连接请求报文段”出现在本连接中

## 总结

### 三次握手流程

1. 客户端发个请求“开门呐，我要进来”给服务器
2. 服务器发个“进来吧，我去给你开门”给客户端
3. 客户端有很客气的发个“谢谢，我要进来了”给服务器

### 四次挥手流程

1. 客户端发个“时间不早了，我要走了”给服务器，等服务器起身送他
2. 服务器听到了，发个“我知道了，那我送你出门吧”给客户端，等客户端走
3. 服务器把门关上后，发个“我关门了”给客户端，然后等客户端走（尼玛~矫情啊）
4. 客户端发个“我知道了，我走了”，之后自己就走了。